// Generated by CoffeeScript 1.6.2
(function() {
  var EDGE_TYPES, Edge, Node, NodeBuilder,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Node = require("./nodes/node");

  Edge = require("./nodes/edge");

  EDGE_TYPES = {
    ONE_ONE: 1,
    ONE_MANY: 2,
    MANY_ONE: 3,
    MANY_MANY: 4
  };

  /*
    Class: NodeBuilder
  
    NodeBuilder takes in a schema path and constructs Nodes and Edges.
    Also provides an interface to surface the graph information to
    a builder instance
  */


  NodeBuilder = (function() {
    function NodeBuilder(_nodeConfigs) {
      this._nodeConfigs = _nodeConfigs;
      this._addParentChildEdges = __bind(this._addParentChildEdges, this);
      this._nodes = [];
    }

    NodeBuilder.prototype.init = function() {
      return this._build();
    };

    /*
      Method: each
    
      Synchronous iteration through each of the nodes.
    */


    NodeBuilder.prototype.each = function(callback) {
      return this._nodes.forEach.call(this._nodes, callback);
    };

    NodeBuilder.prototype.find = function(nodeName) {
      var _n;

      _n = _.filter(this._nodes, function(n) {
        return n.name === nodeName;
      });
      return _n[0];
    };

    NodeBuilder.prototype.__defineGetter__('nodes', function() {
      return this._nodes;
    });

    /*
      Crude build method.  Uses naive iteration
      and isn't smart. Fix after out
    */


    NodeBuilder.prototype._build = function() {
      var n, node, nodeDescription, nodeName, _i, _len, _ref, _ref1, _results;

      _ref = this._nodeConfigs;
      for (nodeName in _ref) {
        nodeDescription = _ref[nodeName];
        n = new Node(nodeName, nodeDescription.serialize());
        n.config();
        this._nodes.push(n);
      }
      _ref1 = this._nodes;
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        node = _ref1[_i];
        _results.push(this._addEdges(node));
      }
      return _results;
    };

    NodeBuilder.prototype._addEdges = function(node) {
      if (node.children != null) {
        if (node.children.one != null) {
          this._addParentChildEdges(node, node.children.one, EDGE_TYPES.ONE_ONE, EDGE_TYPES.ONE_MANY);
        }
        if (node.children.many != null) {
          return this._addParentChildEdges(node, node.children.many, EDGE_TYPES.MANY_ONE, EDGE_TYPES.MANY_MANY);
        }
      }
    };

    NodeBuilder.prototype._addParentChildEdges = function(node, relArray, type1, type2) {
      var _this = this;

      return relArray.forEach(function(childName) {
        var c, child, edge;

        c = _.filter(_this._nodes, function(n) {
          return n.name === childName;
        });
        if (c.length === 0) {
          console.error("Could not find the node instance " + childName);
          return;
        }
        child = c[0];
        if (child.parents == null) {
          console.error("Node pair relationship " + node.name + " - " + child.name + " incorrectly configured.");
        }
        if ((child.parents != null) && _.contains(child.parents.one || [], node.name)) {
          edge = new Edge(node, child, type1);
        } else if ((child.parents != null) && _.contains(child.parents.many || [], node.name)) {
          edge = new Edge(node, child, type2);
        } else {
          console.error("Node " + node.name + " indicated node " + child.name + " is a child, but " + child.name + " does not belong to " + node.name);
          return;
        }
        node.addChildEdge(edge);
        return child.addParentEdge(edge);
      });
    };

    return NodeBuilder;

  })();

  module.exports = NodeBuilder;

}).call(this);
